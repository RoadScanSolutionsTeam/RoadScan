# -*- coding: utf-8 -*-
"""jalanrusak-yolov8s32.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qWahuoPwiAXjVWJnm9f93NvPToayNYtV

# **ROADSCAN SOLUTIONS TEAM**

## **Business Understanding**

Tingginya tingkat kerusakan jalan berlubang di berbagai wilayah Indonesia menyebabkan peningkatan risiko kecelakaan lalu lintas dan menghambat kelancaran mobilitas masyarakat. Kerusakan jalan berlubang mengakibatkan biaya perawatan kendaraan meningkat, waktu tempuh menjadi lebih lama, dan potensi terjadinya kecelakaan yang dapat menimbulkan korban jiwa dan kerugian materi.

## **Data Understanding**

- Lubang: Kerusakan berupa cekungan atau rongga pada permukaan jalan akibat keausan, air, atau beban kendaraan yang berlebihan.
- Melintang: Retakan atau kerusakan yang membentang secara horizontal atau tegak lurus terhadap arah lalu lintas.
- Memanjang: Retakan atau kerusakan yang sejajar dengan arah lalu lintas kendaraan.
- Pinggir: Kerusakan yang terjadi di tepi jalan, sering disebabkan oleh kurangnya dukungan struktural atau drainase yang buruk.
- Retak Buaya: Pola keretakan kecil berbentuk seperti sisik buaya, menandakan kegagalan struktural lapisan jalan.
- Sambungan: Kerusakan atau penurunan kualitas pada titik pertemuan antar lapisan atau bagian jalan, seperti sambungan beton atau aspal.

### **Set-Up, Load Data and Import Library**
"""

# Load Dataset
!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="G0NQkJsvOQBXaZizxR3r")
project = rf.workspace("tugas-xogo7").project("jalanrusak-zofhk")
version = project.version(6)
dataset = version.download("yolov8")

# Set up library
!pip install ultralytics

# import library

# for extracting zip file
import os
import zipfile

# for modelling
from ultralytics import YOLO

# count of images

def count_images_in_folder(folder_path):
  image_count = 0
  for filename in os.listdir(folder_path):
    if filename.endswith((".jpg", ".jpeg", ".png")):
      image_count += 1
  return image_count


train_image_folder = '/content/JalanRusak-6/train/images'
val_image_folder = '/content/JalanRusak-6/valid/images'
test_image_folder = '/content/JalanRusak-6/test/images'

train_image_count = count_images_in_folder(train_image_folder)
val_image_count = count_images_in_folder(val_image_folder)
test_image_count = count_images_in_folder(test_image_folder)

print(f"Number of images in train folder: {train_image_count}")
print(f"Number of images in val folder: {val_image_count}")
print(f"Number of images in test folder: {test_image_count}")

# sum of images

total_images = train_image_count + val_image_count + test_image_count
print(f"Total number of images in all folders: {total_images}")

# count of labels

import os

def count_classes_in_folder(folder_path):
  """Counts the number of unique class labels within a folder containing images and labels.

  Args:
    folder_path: The path to the folder.

  Returns:
    A set of unique class labels found in the folder.
  """
  class_labels = set()
  for filename in os.listdir(folder_path):
    if filename.endswith(".txt"):  # Assuming labels are in .txt files
      filepath = os.path.join(folder_path, filename)
      with open(filepath, 'r') as f:
        for line in f:
          class_id = int(line.split()[0])
          class_labels.add(class_id)
  return class_labels


train_folder = '/content/JalanRusak-6/train/labels'
val_folder = '/content/JalanRusak-6/valid/labels'
test_folder = '/content/JalanRusak-6/test/labels'


train_classes = count_classes_in_folder(train_folder)
val_classes = count_classes_in_folder(val_folder)
test_classes = count_classes_in_folder(test_folder)

print(f"Number of classes in train folder: {len(train_classes)}")
print(f"Number of classes in val folder: {len(val_classes)}")
print(f"Number of classes in test folder: {len(test_classes)}")

import os
import cv2
from matplotlib import pyplot as plt

# Define class names based on your data.yaml
class_names = ["Lubang", "Melintang", "Memanjang", "Pinggir", "Retak Buaya", "Sambungan"]

def show_images_with_labels(image_folder, label_folder, num_images=5):
    """Displays images from a folder along with their corresponding labels.

    Args:
        image_folder: Path to the folder containing images.
        label_folder: Path to the folder containing label files.
        num_images: Number of images to display.
    """

    image_files = [f for f in os.listdir(image_folder) if f.endswith(('.jpg', '.jpeg', '.png'))]
    for image_file in image_files[:num_images]:
        image_path = os.path.join(image_folder, image_file)
        label_file = os.path.join(label_folder, image_file.replace('.jpg', '.txt').replace('.jpeg', '.txt').replace('.png', '.txt'))

        img = cv2.imread(image_path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        if os.path.exists(label_file):
            with open(label_file, 'r') as f:
                for line in f:
                    # Split the line and check if it has enough elements
                    elements = line.split()
                    if len(elements) >= 5:  # Ensure there are at least 5 elements
                        class_id, x_center, y_center, width, height = map(float, elements[:5])  # Take the first 5 elements
                        img_height, img_width, _ = img.shape
                        x_min = int((x_center - width / 2) * img_width)
                        y_min = int((y_center - height / 2) * img_height)
                        x_max = int((x_center + width / 2) * img_width)
                        y_max = int((y_center + height / 2) * img_height)

                        # Get the class name based on the class_id
                        class_name = class_names[int(class_id)] if int(class_id) < len(class_names) else f"Unknown Class {int(class_id)}"

                        # Draw bounding box and label on the image
                        cv2.rectangle(img, (x_min, y_min), (x_max, y_max), (0, 255, 0), 2)
                        cv2.putText(img, class_name, (x_min, y_min - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
                    else:
                        print(f"Warning: Skipping line in {label_file} due to insufficient elements: {line}")

        plt.figure(figsize=(8, 6))
        plt.imshow(img)
        plt.title(image_file)
        plt.axis('off')
        plt.show()

# Paths to your image and label folders
train_image_folder = '/content/JalanRusak-6/train/images'
train_label_folder = '/content/JalanRusak-6/train/labels'

# Display 10 images with labels
show_images_with_labels(train_image_folder, train_label_folder, num_images=10)

# Counts the number of occurrences of each class in a folder of label files.
def count_class_occurrences(label_folder, class_names):
  """Counts the number of occurrences of each class in a folder of label files.

  Args:
    label_folder: The path to the folder containing label files.
    class_names: A list of class names.

  Returns:
    A dictionary where keys are class names and values are the number of occurrences.
  """
  class_counts = {class_name: 0 for class_name in class_names}
  for filename in os.listdir(label_folder):
    if filename.endswith(".txt"):
      filepath = os.path.join(label_folder, filename)
      with open(filepath, 'r') as f:
        for line in f:
          class_id = int(line.split()[0])
          if class_id < len(class_names):
            class_counts[class_names[class_id]] += 1
  return class_counts


train_label_folder = '/content/JalanRusak-6/train/labels'
val_label_folder = '/content/JalanRusak-6/valid/labels'
test_label_folder = '/content/JalanRusak-6/test/labels'

train_class_counts = count_class_occurrences(train_label_folder, class_names)
val_class_counts = count_class_occurrences(val_label_folder, class_names)
test_class_counts = count_class_occurrences(test_label_folder, class_names)

print("Class Counts in Train Folder:")
for class_name, count in train_class_counts.items():
  print(f"{class_name}: {count}")

print("\nClass Counts in Validation Folder:")
for class_name, count in val_class_counts.items():
  print(f"{class_name}: {count}")

print("\nClass Counts in Test Folder:")
for class_name, count in test_class_counts.items():
  print(f"{class_name}: {count}")

"""# Modelling

## Training
"""

# Preprocessing dengan resize sebesar 640 menggunakan model yolov8s
!yolo task=detect mode=train model=yolov8s.pt data="/content/JalanRusak-6/data.yaml" epochs=50 batch=32 imgsz=640 plots=True

"""# Evaluation"""

# Display confusion matrix
from IPython.display import Image

path= "/content/runs/detect"
Image(filename=f"{path}/train/confusion_matrix.png", width=600)

# Display training/validation curve
Image(filename=f"{path}/train/results.png", width=600)

# Sample prediction
Image(filename=f"{path}/train/val_batch0_pred.jpg", width=600)

"""## Validation"""

# Validation Evaluation
!yolo task=detect mode=val model={path}/train/weights/best.pt data="/content/JalanRusak-6/data.yaml"

"""## Testing"""

# Testing evaluation and prediction
!yolo task=detect mode=predict model={path}/train/weights/best.pt conf=0.25 source="/content/JalanRusak-6/test/images" save=True

# Test predict result
import glob
from IPython.display import Image, display

for image_path in glob.glob(f'{path}/predict/*.jpg')[100:150]:
    display(Image(filename=image_path, width=600))
    print("\n")

# Testing with new image
!yolo task=detect mode=predict model={path}/train/weights/best.pt conf=0.25 source="/content/testing1.jpg" save=True

# Testing with new video
# !yolo task=detect mode=predict model={path}/train/weights/best.pt conf=0.25 source="/content/pothole-testing-480-publer.io.mp4" save=True

"""# Insight

Berdasarkan hasil tersebut dapat disimpulkan bahwa model yolov8s dengan epoch 50 dan batch 32 mendapatkan performa paling baik dibanding model dan hyperparameter pembandingnya yang lain. sebagian besar model ini dapat mendeteksi data kerusakan jalan dengan sangat baik dan minim kesalahan.
"""